import{d,u as k,i as v,P as y,a as P,b as R,c as b,e as _,l,s as x,f as N,g as j,_ as w,h as c,m as S,n as T,S as B,p as h,j as O,L as A,k as C,o as E,q as H,w as q,r as U,t as W}from"./D8AEabNB.js";const F=d({name:"LayoutLoader",inheritAttrs:!1,props:{name:String,layoutProps:Object},setup(e,o){return()=>c(l[e.name],e.layoutProps,o.slots)}}),I={name:{type:[String,Boolean,Object],default:null},fallback:{type:[String,Object],default:null}},M=d({name:"NuxtLayout",inheritAttrs:!1,props:I,setup(e,o){const t=k(),a=v(y),u=!a||a===P()?R():a,n=b(()=>{let s=_(e.name)??u?.meta.layout??"default";return s&&!(s in l)&&e.fallback&&(s=_(e.fallback)),s}),i=x();o.expose({layoutRef:i});const r=t.deferHydration();if(t.isHydrating){const s=t.hooks.hookOnce("app:error",r);N().beforeEach(s)}let f;return()=>{const s=n.value&&n.value in l,p=u?.meta.layoutTransition??j,g=f;return f=n.value,w(s&&p,{default:()=>c(B,{suspensible:!0,onResolve:()=>{T(r)}},{default:()=>c(V,{layoutProps:S(o.attrs,{ref:i}),key:n.value||void 0,name:n.value,shouldProvide:!e.name,isRenderingNewLayout:m=>m!==g&&m===n.value,hasTransition:!!p},o.slots)})}).default()}}}),V=d({name:"NuxtLayoutProvider",inheritAttrs:!1,props:{name:{type:[String,Boolean]},layoutProps:{type:Object},hasTransition:{type:Boolean},shouldProvide:{type:Boolean},isRenderingNewLayout:{type:Function,required:!0}},setup(e,o){const t=e.name;e.shouldProvide&&h(A,{isCurrent:u=>t===(u.meta.layout??"default")});const a=v(y);if(a&&a===P()){const u=R(),n={};for(const i in u){const r=i;Object.defineProperty(n,r,{enumerable:!0,get:()=>e.isRenderingNewLayout(e.name)?u[r]:a[r]})}h(y,O(n))}return()=>!t||typeof t=="string"&&!(t in l)?o.slots.default?.():c(F,{key:t,layoutProps:e.layoutProps,name:t},o.slots)}}),$={};function z(e,o){const t=W,a=M;return H(),E(a,null,{default:q(()=>[U(t)]),_:1})}const G=C($,[["render",z]]);export{G as default};
